// File: /Users/home/dev/apps/form_engine/lib/logging/app_logger.dart
import 'file_log_sink.dart';
import 'log_level.dart';
import 'log_sink.dart';

/// Central logging facility for the application.
///
/// Usage:
/// ```dart
/// // Get the singleton instance
/// final logger = AppLogger.instance;
///
/// // Log at various levels
/// logger.info('repo', 'Updated case id=abc123 updatedAt=2026-01-21T15:04:05Z');
/// logger.debug('form', 'Loaded definition schemaVersion=3');
/// logger.warn('persistence', 'Lock contention on case id=xyz');
/// logger.error('io', 'Failed to write file', error: e, stackTrace: stack);
///
/// // PRIVACY: Never log user-entered values like SIN, addresses, money amounts.
/// // Only log: event types, case IDs, group IDs, counts, schema versions, exceptions.
/// ```
class AppLogger {
  static AppLogger? _instance;

  final List<LogSink> _sinks;
  bool _disposed = false;

  /// Minimum log level. Messages below this level are ignored.
  LogLevel minLevel;

  AppLogger._({
    required List<LogSink> sinks,
    this.minLevel = LogLevel.debug,
  }) : _sinks = sinks;

  /// Returns the singleton logger instance.
  /// Initializes with default sinks on first access.
  static AppLogger get instance {
    _instance ??= AppLogger._create();
    return _instance!;
  }

  /// Creates a logger with default sinks for the current platform.
  factory AppLogger._create() {
    final sinks = <LogSink>[
      ConsoleLogSink(),
      // FileLogSink internally checks for Windows; no-ops on other platforms
      FileLogSink(),
    ];

    return AppLogger._(sinks: sinks);
  }

  /// Creates a logger with custom sinks (for testing or dependency injection).
  factory AppLogger.withSinks(List<LogSink> sinks, {LogLevel minLevel = LogLevel.debug}) {
    return AppLogger._(sinks: sinks, minLevel: minLevel);
  }

  void debug(String category, String message, {Object? error, StackTrace? stackTrace}) {
    _log(LogLevel.debug, category, message, error: error, stackTrace: stackTrace);
  }

  void info(String category, String message, {Object? error, StackTrace? stackTrace}) {
    _log(LogLevel.info, category, message, error: error, stackTrace: stackTrace);
  }

  void warn(String category, String message, {Object? error, StackTrace? stackTrace}) {
    _log(LogLevel.warn, category, message, error: error, stackTrace: stackTrace);
  }

  void error(String category, String message, {Object? error, StackTrace? stackTrace}) {
    _log(LogLevel.error, category, message, error: error, stackTrace: stackTrace);
  }

  void _log(LogLevel level, String category, String message, {Object? error, StackTrace? stackTrace}) {
    if (level.index < minLevel.index) return;

    for (final sink in _sinks) {
      try {
        sink.write(level, category, message, error: error, stackTrace: stackTrace);
      } catch (_) {
        // Silently ignore sink failures to prevent logging from crashing the app
      }
    }
  }

  /// Disposes all sinks. Call on app shutdown if needed.
  /// Safe to call multiple times.
  void dispose() {
    if (_disposed) return;
    _disposed = true;
    for (final sink in _sinks) {
      try {
        sink.dispose();
      } catch (_) {}
    }
  }
}


// File: /Users/home/dev/apps/form_engine/lib/logging/file_log_sink.dart
import 'dart:async';
import 'dart:io';

import 'package:flutter/foundation.dart';

import 'log_level.dart';
import 'log_paths.dart';
import 'log_sink.dart';

/// Writes logs to daily-rotated files on Windows.
/// Falls back to no-op on unsupported platforms or if directory creation fails.
class FileLogSink implements LogSink {
  static const int _retentionDays = 14;
  static const int _flushThreshold = 20;
  static const Duration _flushInterval = Duration(seconds: 5);

  final String? _baseDir;
  IOSink? _currentSink;
  String? _currentFilename;
  bool _initialized = false;
  bool _disabled = false;
  bool _disposed = false;
  bool _warnedInitFailure = false;
  int _linesSinceFlush = 0;
  Timer? _flushTimer;

  FileLogSink() : _baseDir = _getBaseDir();

  static String? _getBaseDir() {
    if (kIsWeb) return null;
    // Only enable file logging on Windows
    if (!Platform.isWindows) return null;
    return LogPaths.getLogDirectory();
  }

  @override
  void write(LogLevel level, String category, String message, {Object? error, StackTrace? stackTrace}) {
    if (_disposed || _disabled || _baseDir == null) return;

    _ensureInitialized();
    if (_disabled) return;

    final sink = _getSinkForToday();
    if (sink == null) return;

    final timestamp = DateTime.now().toUtc().toIso8601String();
    final line = '[$timestamp] [${level.label}] [$category] $message';
    sink.writeln(line);
    _linesSinceFlush++;

    if (error != null) {
      sink.writeln('  Error: $error');
      _linesSinceFlush++;
    }
    if (stackTrace != null) {
      sink.writeln('  StackTrace:\n$stackTrace');
      _linesSinceFlush++;
    }

    // Flush immediately for warn/error, otherwise use buffered strategy
    if (level == LogLevel.warn || level == LogLevel.error) {
      _flush();
    } else if (_linesSinceFlush >= _flushThreshold) {
      _flush();
    } else {
      _scheduleFlush();
    }
  }

  void _flush() {
    _flushTimer?.cancel();
    _flushTimer = null;
    _currentSink?.flush();
    _linesSinceFlush = 0;
  }

  void _scheduleFlush() {
    if (_flushTimer != null) return;
    _flushTimer = Timer(_flushInterval, _flush);
  }

  void _ensureInitialized() {
    if (_initialized) return;
    _initialized = true;

    try {
      final dir = Directory(_baseDir!);
      if (!dir.existsSync()) {
        dir.createSync(recursive: true);
      }
      _rotateOldLogs();
    } catch (e) {
      _disableWithWarning('Failed to initialize log directory: $e');
    }
  }

  void _disableWithWarning(String reason) {
    if (_warnedInitFailure) return;
    _warnedInitFailure = true;
    _disabled = true;
    debugPrint('[AppLogger] File logging disabled: $reason');
  }

  IOSink? _getSinkForToday() {
    final today = DateTime.now();
    final filename = LogPaths.filenameForDate(today);

    if (_currentFilename == filename && _currentSink != null) {
      return _currentSink;
    }

    // Close previous sink if switching days
    _currentSink?.close();
    _currentSink = null;
    _currentFilename = null;

    try {
      final filePath = '$_baseDir${Platform.pathSeparator}$filename';
      final file = File(filePath);
      _currentSink = file.openWrite(mode: FileMode.append);
      _currentFilename = filename;
      return _currentSink;
    } catch (e) {
      _disableWithWarning('Failed to open log file: $e');
      return null;
    }
  }

  void _rotateOldLogs() {
    try {
      final dir = Directory(_baseDir!);
      if (!dir.existsSync()) return;

      final cutoff = DateTime.now().subtract(const Duration(days: _retentionDays));

      for (final entity in dir.listSync()) {
        if (entity is! File) continue;

        final filename = entity.uri.pathSegments.last;
        final fileDate = LogPaths.parseDateFromFilename(filename);
        if (fileDate == null) continue;

        if (fileDate.isBefore(cutoff)) {
          try {
            entity.deleteSync();
          } catch (_) {
            // Ignore deletion failures
          }
        }
      }
    } catch (_) {
      // Ignore rotation failures
    }
  }

  @override
  void dispose() {
    if (_disposed) return;
    _disposed = true;
    _flushTimer?.cancel();
    _flushTimer = null;
    try {
      _currentSink?.flush();
      _currentSink?.close();
    } catch (_) {}
    _currentSink = null;
    _currentFilename = null;
  }
}


// File: /Users/home/dev/apps/form_engine/lib/logging/log_level.dart
/// Log severity levels in ascending order of importance.
enum LogLevel {
  debug,
  info,
  warn,
  error;

  String get label {
    switch (this) {
      case LogLevel.debug:
        return 'DEBUG';
      case LogLevel.info:
        return 'INFO';
      case LogLevel.warn:
        return 'WARN';
      case LogLevel.error:
        return 'ERROR';
    }
  }
}


// File: /Users/home/dev/apps/form_engine/lib/logging/log_paths.dart
import 'dart:io';

/// Helper for determining log file paths.
class LogPaths {
  static const String windowsBaseDir = r'C:\ProgramData\YourApp\logs';

  /// Returns the base log directory for the current platform.
  /// Returns null if file logging is not supported on this platform.
  static String? getLogDirectory() {
    if (Platform.isWindows) {
      return windowsBaseDir;
    }
    // Mac/Linux: could add ~/Library/Logs or ~/.local/share, but disabled for now
    return null;
  }

  /// Generates a log filename for the given date.
  static String filenameForDate(DateTime date) {
    final year = date.year.toString();
    final month = date.month.toString().padLeft(2, '0');
    final day = date.day.toString().padLeft(2, '0');
    return 'app_$year-$month-$day.log';
  }

  /// Parses a date from a log filename, or returns null if not matching pattern.
  static DateTime? parseDateFromFilename(String filename) {
    final regex = RegExp(r'^app_(\d{4})-(\d{2})-(\d{2})\.log$');
    final match = regex.firstMatch(filename);
    if (match == null) return null;

    try {
      final year = int.parse(match.group(1)!);
      final month = int.parse(match.group(2)!);
      final day = int.parse(match.group(3)!);
      return DateTime(year, month, day);
    } catch (_) {
      return null;
    }
  }
}


// File: /Users/home/dev/apps/form_engine/lib/logging/log_sink.dart
import 'package:flutter/foundation.dart';
import 'log_level.dart';

/// Interface for log output destinations.
abstract class LogSink {
  void write(LogLevel level, String category, String message, {Object? error, StackTrace? stackTrace});
  void dispose() {}
}

/// Outputs logs to the console via debugPrint (debug mode only).
class ConsoleLogSink implements LogSink {
  @override
  void write(LogLevel level, String category, String message, {Object? error, StackTrace? stackTrace}) {
    if (!kDebugMode) return;

    final timestamp = DateTime.now().toUtc().toIso8601String();
    final line = '[$timestamp] [${level.label}] [$category] $message';
    debugPrint(line);

    if (error != null) {
      debugPrint('  Error: $error');
    }
    if (stackTrace != null) {
      debugPrint('  StackTrace:\n$stackTrace');
    }
  }

  @override
  void dispose() {}
}


